#include <iostream>
#include <fstream> // acesso a biblioteca com as funções que permitem o uso dos arquivos
#include <locale.h> // permitir a acentuação
#include <cstring>
#include <cstdlib>
#include <time.h>
#include <dos.h>

#define STRMAX 50

using namespace std;

struct Img{
    int linhas;
    int colunas;
    int M[512][512][3];
};

void abre_img(char nome[], Img& img){
    fstream arq;

    int  pixels, k=0;
    char tipo[3]; // declara uma variavel char para armazenar o tipo da imagem

    arq.open(nome);

    if(arq.is_open()){
        arq.getline(tipo, 3);
        if(strcmp("P3",tipo)!=0){
            cout<<"ERRO\n";
            exit(0);
        }
        arq >> img.colunas;
        arq >> img.linhas;
        arq>> pixels;

        int i, j;

        for(i=0; i<img.linhas; i++){
            for(j=0; j<img.colunas; j++){
               for(k=0; k<3; k++){
                    arq >> img.M[i][j][k];
               }
            }
        }
        arq.close();
    }

    else{
        cout << nome << " não foi localizada. Verifique se esta imagem está contida na pasta!\n";
        exit(0);
    }
}
void salva_img(char nome[],Img img){
    ofstream myfile;

    myfile.open(nome);

    if(myfile.is_open()){
        myfile << "P3"<<endl;

        myfile << img.colunas << " " << img.linhas << "\n" << 255 << endl;

        int i, j,k;

        for(i=0; i<img.linhas; i++){
            for(j=0; j<img.colunas; j++){
               for(k=0; k<3; k++){
                    myfile << img.M[i][j][k] << " ";
               }
            }

            myfile << endl;
        }
        myfile.close();
    }
}

void escolha_nome(char nome[]){
    cout << "Como você deseja salvar o arquivo? ";
    cin >> nome;
}

void corta_rgb(Img img_in, Img& img_out, int li, int ci, int lf, int cf){

    char nome[50];

    int i, j, k;

    img_out.linhas= lf-li;
    img_out.colunas= cf-ci;

    for(i=li; i<=lf; i++){
        for(j=ci; j<=cf; j++){
            for(k=0; k<3; k++){
                img_out.M[i][j][k] = img_in.M[i][j][k];
            }
        }
    }

    escolha_nome(nome);
    salva_img(nome, img_out);
}

void escolha_limiar(int& limiar){

    cout << endl<< "Qual é o limiar desejado por você? ";
    cin >> limiar;

}

void diminui_tamanho(Img img_in, Img& img_out){
    int i=0, j=0, k, linhas, colunas;
    char nome[50];

    img_out.linhas= img_in.linhas/2;
    img_out.colunas= img_in.colunas/2;

    for(linhas=0; linhas<img_out.linhas; linhas++){
        if(i%2!=0){
            i++;
        }
        for(colunas=0; colunas<img_out.colunas; colunas++){
            if(j%2!=0){
                j++;
            }
            for(k=0; k<3; k++){
                img_out.M[linhas][colunas][k] = img_in.M[i][j][k];
            }
            j++;
        }
        j=0;
        i++;
    }


    escolha_nome(nome);
    salva_img(nome, img_out);
}

void rotaciona(Img img_in, Img& img_out){
    int i, j, k;
    char nome[50];

    img_out.linhas= img_in.colunas;
    img_out.colunas = img_in.linhas;

    for(i=0; i<img_in.linhas; i++){
        for(j=0; j<img_in.colunas; j++){
            for(k=0; k<3; k++){
                img_out.M[i][j][k] = img_in.M[img_in.colunas-j][i][k];
            }
        }
    }

    escolha_nome(nome);
    salva_img(nome, img_out);
}

void rotaciona_antihorario(Img img_in, Img& img_out){
    int i, j, k;
    char nome[50];

    img_out.linhas= img_in.colunas;
    img_out.colunas = img_in.linhas;

    for(i=0; i<img_in.linhas; i++){
        for(j=0; j<img_in.colunas; j++){
            for(k=0; k<3; k++){
                img_out.M[i][j][k] = img_in.M[j][img_in.linhas-i][k];
            }
        }
    }

    escolha_nome(nome);
    salva_img(nome, img_out);
}

void aumenta_tamanho(Img img_in, Img& img_out){
    int i1,j1,i2,j2,k;
    char nome[50];

    img_out.colunas=2*img_in.colunas-1;
    img_out.linhas=2*img_in.linhas-1;

    for(i1=0;i1<img_in.linhas;i1++){
        for(j1=0;j1<img_in.colunas;j1++){
            for(k=0;k<3;k++){
                img_out.M[2*i1][2*j1][k]=img_in.M[i1][j1][k];
            }
        }
    }
     //primeira etapa
    for(i2=1;i2<img_out.linhas;i2+=2){
        for(k=0;k<3;k++){
            img_out.M[i2][0][k]=(img_out.M[i2-1][0][k]+img_out.M[i2+1][0][k])/2;
            img_out.M[i2][img_out.colunas-1][k]=(img_out.M[i2-1][img_out.colunas-1][k]+img_out.M[i2+1][img_out.colunas-1][k])/2;
        }
    }
    for(j2=1;j2<img_out.colunas;j2+=2){
        for(k=0;k<3;k++){
            img_out.M[0][j2][k]=(img_out.M[0][j2-1][k]+img_out.M[0][j2+1][k])/2;
            img_out.M[img_out.linhas-1][j2][k]=(img_out.M[img_out.linhas-1][j2-1][k]+img_out.M[img_out.linhas-1][j2-1][k])/2;
        }
    }
    //segunda etapa
    for(i2=1;i2<img_out.linhas;i2+=2){
        for(j2=1;j2<img_out.colunas;j2+=2){
            for(k=0;k<3;k++){
                img_out.M[i2][j2][k]=img_out.M[i2-1][j2-1][k]+img_out.M[i2-1][j2+1][k]+img_out.M[i2+1][j2-1][k]+img_out.M[i2+1][j2+1][k];
                img_out.M[i2][j2][k]=img_out.M[i2][j2][k]/4;
            }
        }
    }
    //terceira etapa
    for(i2=1;i2<img_out.linhas;i2+=2){
        for(j2=1;j2<img_out.colunas;j2+=2){
            if((i2%2==0 && j2%2!=0)|| (i2%2!=0 && j2%2==0)){
                for(k=0;k<3;k++){
                    img_out.M[i2][j2][k]=img_out.M[i2-1][j2][k]+img_out.M[i2+1][j2][k]+img_out.M[i2][j2-1][k]+img_out.M[i2][j2+1][k];
                    img_out.M[i2][j2][k]=img_out.M[i2][j2][k]/4;
                }
            }
        }
    }


    escolha_nome(nome);
    salva_img(nome, img_out);
}

Img mascara (Img& img_in){
    int i, j;

    for (j=0; j<img_in.colunas/2; j++){
        for (i=0; i<img_in.linhas; i++){
            img_in.M[i][j][0] = 0;
            img_in.M[i][j][1] = 0;
            img_in.M[i][j][2] = 0;
        }
    }

    for (j=img_in.colunas/2; j<img_in.colunas; j++){
        for (i=0; i<img_in.colunas; i++){
            img_in.M[i][j][0] = 255;
            img_in.M[i][j][1] = 255;
            img_in.M[i][j][2] = 255;
        }
    }

}

void binariza(Img img_in, Img& img_out, int limiar){
    int i, j;
    char nome[50];

    img_out.linhas = img_in.linhas;
    img_out.colunas = img_in.colunas;

    for(i=0; i< img_in.linhas; i++){
        for(j=0; j < img_in.colunas; j++){
            int media = (img_in.M[i][j][0] + img_in.M[i][j][1] + img_in.M[i][j][2])/3;
            if (media < limiar) {
                img_out.M[i][j][0] = 0;
                img_out.M[i][j][1] = 0;
                img_out.M[i][j][2] = 0;
            }
            else{
                img_out.M[i][j][0] = 255;
                img_out.M[i][j][1] = 255;
                img_out.M[i][j][2] = 255;
            }
        }
    }

    escolha_nome(nome);
    salva_img(nome, img_out);
}

void binariza_com_mascara(Img img_in, Img& img_out, int limiar){
    int i, j, media;
    char nome[50];
    Img aux= img_in;

    img_out.linhas = img_in.linhas;
    img_out.colunas = img_in.colunas;

    mascara(aux);

    for(i=0; i< img_in.linhas; i++){
        for(j=0; j < img_in.colunas; j++){
            if (aux.M[i][j][0]==255 && aux.M[i][j][1]==255 && aux.M[i][j][2]==255){
                media = (img_in.M[i][j][0] + img_in.M[i][j][1] + img_in.M[i][j][2])/3;
                if (media < limiar) {
                    img_out.M[i][j][0] = 0;
                    img_out.M[i][j][1] = 0;
                    img_out.M[i][j][2] = 0;
                }
                else{
                    img_out.M[i][j][0] = 255;
                    img_out.M[i][j][1] = 255;
                    img_out.M[i][j][2] = 255;
                }
            }
            else {
                img_out.M[i][j][0] = img_in.M[i][j][0];
                img_out.M[i][j][1] = img_in.M[i][j][1];
                img_out.M[i][j][2] = img_in.M[i][j][2];
            }
        }
    }

    escolha_nome(nome);
    salva_img(nome, img_out);
}

void cinza(Img img_in, Img& img_out){
    int i, j;
    char nome[50];

    img_out.linhas = img_in.linhas;
    img_out.colunas = img_in.colunas;

    for(i=0; i< img_in.linhas; i++){
        for(j=0; j < img_in.colunas; j++){
            int media = (img_in.M[i][j][0] + img_in.M[i][j][1] + img_in.M[i][j][2])/3;
                img_out.M[i][j][0] = media;
                img_out.M[i][j][1] = media;
                img_out.M[i][j][2] = media;
        }
    }

    escolha_nome(nome);
    salva_img(nome, img_out);
}

void negativo (Img img_in, Img& img_out){
    char nome[50];

    for (int i=0; i<img_in.linhas; i++){
        for (int j=0; j<img_in.colunas; j++){
            img_out.M[i][j][0] = 255-img_in.M[i][j][0];
            img_out.M[i][j][1] = 255-img_in.M[i][j][1];
            img_out.M[i][j][2] = 255-img_in.M[i][j][2];
        }
    }

    escolha_nome(nome);
    salva_img(nome, img_out);
}

void binariza_canal(Img img_in, Img& img_out, int limiar){
    int i, j;
    char nome[50];

    img_out.linhas = img_in.linhas;
    img_out.colunas = img_in.colunas;

    for(i=0; i<img_in.linhas; i++){
        for(j=0; j<img_in.colunas; j++){

            if (img_in.M[i][j][0]>=limiar){//vermelho
                img_out.M[i][j][0]=255;
            }
            else {
                img_out.M[i][j][0]=0;
            }

            if (img_in.M[i][j][1]>=limiar){//verde
                img_out.M[i][j][1]=255;
            }
            else {
                img_out.M[i][j][1]=0;
            }

            if (img_in.M[i][j][2]>=limiar){//azul
                img_out.M[i][j][2]=255;
            }
            else {
                img_out.M[i][j][2]=0;
            }

        }
    }

    escolha_nome(nome);
    salva_img(nome,img_out);
}

void equaliza_histograma(Img img_in, Img& img_out){
    char nome[50];

    img_out.linhas=img_in.linhas;
    img_out.colunas=img_in.colunas;

    int h[3][256]={};
    int pixel,s;
    for(int i=0;i<img_in.linhas;i++){
        for(int j=0;j<img_in.colunas;j++){
            for(int k=0;k<3;k++){
                pixel=img_in.M[i][j][k];
                h[k][pixel]++;
            }
        }
    }
    for(int i=0;i<img_in.linhas;i++){
        for(int j=0;j<img_in.colunas;j++){
            for(int k=0;k<3;k++){
                s=0;
                for(int l=0;l<=img_in.M[i][j][k];l++){
                    s=s+h[k][l];
                }
                s=s*(255/(img_in.linhas*img_in.colunas));
                img_out.M[i][j][k]=s;
            }
        }
    }

    escolha_nome(nome);
    salva_img(nome, img_out);

}

void solariza (Img img_in, Img& img_out, int limiar){
    int i, j,k;
    char nome[50];

    for(i=0; i<img_in.linhas; i++){
        for(j=0; j<img_in.colunas; j++){
            for(k=0; k<3; k++){
                if (img_in.M[i][j][0]<limiar){//vermelho
                    img_out.M[i][j][k]=255-img_in.M[i][j][k];
                }

                else{
                    img_out.M[i][j][k]=img_in.M[i][j][k];
                }
            }
        }
    }

    img_out.linhas = img_in.linhas;
    img_out.colunas = img_in.colunas;

    escolha_nome(nome);
    salva_img(nome, img_out);
}

void separa_canais (Img img_in, Img& img_r, Img& img_g, Img& img_b){

    for (int i=0; i<img_in.linhas; i++){
        for (int j=0; j<img_in.colunas; j++){

            img_r.M[i][j][0] = img_in.M[i][j][0];//vermelho
            img_r.M[i][j][1] = 0;
            img_r.M[i][j][2] = 0;


            img_g.M[i][j][1] = img_in.M[i][j][1];//verde
            img_r.M[i][j][0] = 0;
            img_r.M[i][j][2] = 0;

            img_b.M[i][j][2] = img_in.M[i][j][2];//azul
            img_r.M[i][j][0] = 0;
            img_r.M[i][j][1] = 0;

        }
    }

    img_r.colunas= img_in.colunas;
    img_r.linhas= img_in.linhas;

    img_g.colunas= img_in.colunas;
    img_g.linhas= img_in.linhas;

    img_b.colunas= img_in.colunas;
    img_b.linhas= img_in.linhas;

    salva_img("red.ppm", img_r);
    salva_img("green.ppm",img_g);
    salva_img("blue.ppm",img_b);

}


void inverte_verticalmente(Img img_in, Img& img_out){
    int i, j, k;
    char nome[50];

    img_out.linhas= img_in.linhas;
    img_out.colunas = img_in.colunas;

    for(i=0; i<img_in.linhas; i++){
        for(j=0; j<img_in.colunas; j++){
            for(k=0; k<3; k++){
                img_out.M[i][j][k] = img_in.M[img_in.linhas-i][j][k];
            }
        }
    }

    escolha_nome(nome);
    salva_img(nome, img_out);
}

void inverte_horizontalmente(Img img_in, Img& img_out){
    int i, j, k;
    char nome[50];

    img_out.linhas= img_in.linhas;
    img_out.colunas = img_in.colunas;

    for(i=0; i<img_in.linhas; i++){
        for(j=0; j<img_in.colunas; j++){
            for(k=0; k<3; k++){
                img_out.M[i][j][k] = img_in.M[i][img_in.colunas-j][k];
            }
        }
    }

    escolha_nome(nome);
    salva_img(nome, img_out);
}

void reflete_horizontalmente(Img img_in, Img& img_out){
    int i, j, k, meio_fim=img_in.colunas/2, meio_inicio=img_in.colunas/2;
    char nome[50];

    img_out.linhas= img_in.linhas;
    img_out.colunas = img_in.colunas;

    for(j=0; j<=img_in.colunas/2; j++){
        for(i=0; i<img_in.linhas; i++){
            for(k=0; k<3; k++){
                img_out.M[i][meio_inicio][k] = img_in.M[i][img_in.colunas/2+j][k];
                img_out.M[i][meio_fim][k] = img_in.M[i][img_in.colunas/2+j][k];
            }
        }
        meio_inicio--;
        meio_fim++;
    }

    escolha_nome(nome);
    salva_img(nome, img_out);
}

void reflete_verticalmente(Img img_in, Img& img_out){
    int i, j, k, meio_fim=img_in.linhas/2, meio_inicio=img_in.linhas/2;

    img_out.linhas= img_in.linhas;
    img_out.colunas = img_in.colunas;

    for(i=0; i<=img_in.linhas/2; i++){
        for(j=0; j<img_in.colunas; j++){
            for(k=0; k<3; k++){
                img_out.M[meio_inicio][j][k] = img_in.M[img_in.linhas/2+i][j][k];
                img_out.M[meio_fim][j][k] = img_in.M[img_in.linhas/2+i][j][k];
            }
        }
        meio_inicio--;
        meio_fim++;
    }

    salva_img("Nova_imagem_refletida_verti.ppm", img_out);
}

void filtragem_por_erosao(Img img_in, Img& img_out){
    int i,j,k;
    char nome[50];

    binariza(img_in,img_out, 127);
    img_out.linhas = img_in.linhas-1;
    img_out.colunas = img_in.colunas-1;

    for(i=0; i<img_out.linhas; i++)
    {
        for(j=0; j<img_out.colunas; j++)
        {
            for(k=0; k<3; k++)
            {
                if(img_in.M[i][j][k]==1 && img_in.M[i+1][j][k]==1 && img_in.M[i][j+1][k]==1 && img_in.M[i+1][j+1][k]==1)
                {
                    img_out.M[i][j][k]= 255;
                }
                else
                {
                    img_out.M[i][j][k]= 0;
                }

            }
        }
    }

    escolha_nome(nome);
    salva_img (nome, img_out);
}

void filtragem_por_dilatacao(Img img_in, Img& img_out){
    int i,j,k;
    char nome[50];

    binariza(img_in,img_out,127);
    img_out.linhas = img_in.linhas-1;
    img_out.colunas = img_in.colunas-1;

    for(i=0; i<img_out.linhas; i++)
    {
        for(j=0; j<img_out.colunas; j++)
        {
            for(k=0; k<3; k++)
            {
                if(img_in.M[i][j][k]==1 || img_in.M[i+1][j][k]==1 || img_in.M[i][j+1][k]==1 || img_in.M[i+1][j+1][k]==1)
                {
                    img_out.M[i][j][k]= 255;
                }
                else
                {
                    img_out.M[i][j][k]= 0;
                }

            }
        }
    }
    salva_img("filtragem_por_dilatacao.ppm", img_out);
}



int main(){

    setlocale(LC_ALL, "Portuguese"); // permite a utilização de acentos provenientes da lingua portuguesa
    Img img;
    int x, limiar,tempo;
    char nome[50];

    cout <<"Informe o nome do arquivo que voce deseja abrir: " << endl;
    cin >> nome;

    system("cls");
    abre_img(nome,img);

    do{

        //Menu da função

        cout<<endl<<"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~MENU~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~" << endl;
        cout<<" \t 1 - Aumentar tamanho \n";
        cout<<" \t 2 - Binarizar (preto e branco)\n ";
        cout<<" \t 3- Binarizar (preto e branco com máscara)\n ";
        cout<<" \t 4 - Binarizar (por canal) \n ";
        cout<<" \t 5 - Computar negativo \n ";
        cout<<" \t 6 - Converter para niveis de cinza \n ";
        cout<<" \t 7 - Cortar imagem \n";
        cout<<" \t 8 - Equalizar Histograma \n ";
        cout<<" \t 9 - Filtrar com dilatacao \n ";
        cout<<" \t 10 - Filtrar com erosão \n ";
        cout<<" \t 11- Filtrar com mediana \n ";
        cout<<" \t 12- Filtrar com Passa Altas \n ";
        cout<<" \t 13- Filtrar com Passa Baixas (tamanho fixo) \n ";
        cout<<" \t 14- Filtrar com Passa Baixas (tamanho variavel) \n ";
        cout<<" \t 15- Inverter imagem (horizontalmente)\n ";
        cout<<" \t 16- Inverter imagem (verticalmente) \n";
        cout<<" \t 17- Reduzir tamanho \n ";
        cout<<" \t 18- Refletir imagem (horizontalmente) \n ";
        cout<<" \t 19- Refletir imagem (verticalmente) \n ";
        cout<<" \t 20- Rotacionar imagem (anti-horario) \n ";
        cout<<" \t 21- Rotacionar imagem (horario) \n";
        cout<<" \t 22- Separa canais \n ";
        cout <<"\t 23- Solarizar \n";
        cout<<"\t 24- Sair \n ";

        cout << endl << "Qual opção você deseja escolher? ";
        cin >> x;

        switch(x){
            case 1:
                Img tamanhoaumentado;
                aumenta_tamanho(img, tamanhoaumentado);
            break;

            case 2:
                Img pretoebranco;
                escolha_limiar(limiar);

                binariza(img, pretoebranco,limiar);
            break;

            case 3:
                Img mascarapretoebranco;
                escolha_limiar(limiar);

                binariza_com_mascara(img, mascarapretoebranco, limiar);
            break;

            case 4:
                Img canal;
                escolha_limiar(limiar);
                binariza_canal(img, canal, 127);
            break;

            case 5:
                Img ngt;
                negativo(img, ngt);
            break;

            case 6:
                Img acinzentada;
                cinza(img, acinzentada);
            break;

            case 7:
                Img cortada;
                int li, ci, lf, cf;

                cout << "Informe a linha inicial, linha final, coluna inicial e coluna final: ";
                cin >> li >> lf >> ci >> cf;

                corta_rgb(img, cortada, li, ci, lf, cf);

            break;

            case 8:
                Img equalizada_histograma;
                equaliza_histograma(img, equalizada_histograma);
            break;

            case 9:
                Img filtrada_dilatacao;
                filtragem_por_dilatacao(img, filtrada_dilatacao);
            break;

            case 10:
                Img filtrada_erosao;
                filtragem_por_erosao(img, filtrada_erosao);
            break;

            case 11:

            break;

            case 12:

            break;

            case 13:

            break;

            case 14:

            break;

            case 15:
                Img invertidahorizontalmente;
                inverte_horizontalmente(img, invertidahorizontalmente);
            break;

            case 16:
                Img invertidaverticalmente;
                inverte_verticalmente(img, invertidaverticalmente);
            break;

            case 17:
                Img tamanhoreduzido;
                diminui_tamanho(img, tamanhoreduzido);
            break;

            case 18:
                Img refletida_horizontalmente;
                reflete_horizontalmente(img, refletida_horizontalmente);
            break;

            case 19:
                Img refletida_verticalmente;
                reflete_verticalmente(img, refletida_verticalmente);
            break;

            case 20:
                Img horario;
                rotaciona(img, horario);
            break;

            case 21:
                Img antihorario;
                rotaciona_antihorario(img, antihorario);
            break;

            case 22:
                Img red, green, blue;
                separa_canais(img, red, green, blue);
            break;

            case 23:
                Img solarizada;

                escolha_limiar(limiar);
                solariza(img, solarizada,limiar);
            break;

            case 24:
                system("cls");
                cout << "xau xau!";
            break;

        }
        if(x!=24){
            system("cls");

            tempo = clock();
            cout <<"\n\n\n\n\n\n\t ~~~~Voltando para o Menu!~~~~";

            while(clock() - tempo < 5000){

            }

            system("cls");

        }
    }while(x!=24);

    return 0;
}
