#include <iostream>
#include <fstream> // acesso a biblioteca com as funções que permitem o uso dos arquivos
#include <locale.h> // permitir a acentuação
#include <cstring>
#include <cstdlib>

using namespace std;

struct Img{
    int linhas;
    int colunas;
    int M[512][512][3];
};

void abre_img(char nome[], Img& img){
    fstream arq;

    int  pixels, k=0;
    char tipo[3]; // declara uma variavel char para armazenar o tipo da imagem

    arq.open(nome);

    if(arq.is_open()){
        //cout << "Está aberto!\n";
        arq.getline(tipo, 3);
        if(strcmp("P3",tipo)!=0){
            cout<<"ERRO\n";
            exit(0);
        }
        arq >> img.colunas;
        arq >> img.linhas;
        arq>> pixels;

        int i, j;

        for(i=0; i<img.linhas; i++){
            for(j=0; j<img.colunas; j++){
               for(k=0; k<3; k++){
                    arq >> img.M[i][j][k];
               }
            }
        }
        arq.close();
    }

    else{
        cout << "Não está aberto!\n";
        exit(0);
    }
}
void salva_img(char nome[],Img img){
    ofstream myfile;

    myfile.open(nome);

    if(myfile.is_open()){
        myfile << "P3"<<endl;

        myfile << img.colunas << " " << img.linhas << "\n" << 255 << endl;

        int i, j,k;

        for(i=0; i<img.linhas; i++){
            for(j=0; j<img.colunas; j++){
               for(k=0; k<3; k++){
                    myfile << img.M[i][j][k] << " ";
               }
            }

            myfile << endl;
        }
        myfile.close();
    }
}

void corta_rgb(Img img_in, Img& img_out, int li, int ci, int lf, int cf){

    char nome[]= "lake.ppm";

    int i, j, k;

    for(i=li; i<=lf; i++){
        for(j=ci; j<=cf; j++){
            for(k=0; k<3; k++){
                img_out.M[i][j][k] = img_in.M[i][j][k];
            }
        }
    }

    img_out.linhas= lf-li;
    img_out.colunas= cf-ci;

    salva_img("Nova_imagem_cortada.ppm", img_out);
}

void diminui_tamanho(Img img_in, Img& img_out){
    int i=0, j=0, k, linhas, colunas;

    for(linhas=0; linhas<img_in.linhas; linhas++){
        if(i%2!=0){
            i++;
        }
        for(colunas=0; colunas<img_in.colunas; colunas++){
            if(j%2!=0){
                j++;
            }
            for(k=0; k<3; k++){
                img_out.M[linhas][colunas][k] = img_in.M[i][j][k];
            }
            j++;
        }
        i++;
    }

    img_out.linhas= img_in.linhas/2;
    img_out.colunas= img_in.colunas/2;

    salva_img("Nova_imagem_reduzida.ppm", img_out);
}

void rotaciona(Img img_in, Img& img_out){
    int i, j, k;

    img_out.linhas= img_in.colunas;
    img_out.colunas = img_in.linhas;

    for(i=0; i<img_in.linhas; i++){
        for(j=0; j<img_in.colunas; j++){
            for(k=0; k<3; k++){
                img_out.M[i][j][k] = img_in.M[img_in.colunas-j][i][k];
            }
        }
    }

    salva_img("Nova_imagem_rotacionada1.ppm", img_out);
}

void rotaciona_antihorario(Img img_in, Img& img_out){
    int i, j, k;

    img_out.linhas= img_in.colunas;
    img_out.colunas = img_in.linhas;

    for(i=0; i<img_in.linhas; i++){
        for(j=0; j<img_in.colunas; j++){
            for(k=0; k<3; k++){
                img_out.M[i][j][k] = img_in.M[j][img_in.linhas-i][k];
            }
        }
    }

    salva_img("Nova_imagem_rotacionada_antihorario.ppm", img_out);
}

void aumenta_tamanho(Img img_in, Img& img_out){
    int i1,j1,i2,j2,k;
    img_out.colunas=2*img_in.colunas-1;
    img_out.linhas=2*img_in.linhas-1;

    for(i1=0;i1<img_in.linhas;i1++){
        for(j1=0;j1<img_in.colunas;j1++){
            for(k=0;k<3;k++){
                img_out.M[2*i1][2*j1][k]=img_in.M[i1][j1][k];
            }
        }
    }
     //primeira etapa
    for(i2=1;i2<img_out.linhas;i2+=2){
        for(k=0;k<3;k++){
            img_out.M[i2][0][k]=(img_out.M[i2-1][0][k]+img_out.M[i2+1][0][k])/2;
            img_out.M[i2][img_out.colunas-1][k]=(img_out.M[i2-1][img_out.colunas-1][k]+img_out.M[i2+1][img_out.colunas-1][k])/2;
        }
    }
    for(j2=1;j2<img_out.colunas;j2+=2){
        for(k=0;k<3;k++){
            img_out.M[0][j2][k]=(img_out.M[0][j2-1][k]+img_out.M[0][j2+1][k])/2;
            img_out.M[img_out.linhas-1][j2][k]=(img_out.M[img_out.linhas-1][j2-1][k]+img_out.M[img_out.linhas-1][j2-1][k])/2;
        }
    }
    //segunda etapa
    for(i2=1;i2<img_out.linhas;i2+=2){
        for(j2=1;j2<img_out.colunas;j2+=2){
            for(k=0;k<3;k++){
                img_out.M[i2][j2][k]=img_out.M[i2-1][j2-1][k]+img_out.M[i2-1][j2+1][k]+img_out.M[i2+1][j2-1][k]+img_out.M[i2+1][j2+1][k];
                img_out.M[i2][j2][k]=img_out.M[i2][j2][k]/4;
            }
        }
    }
    //terceira etapa
    for(i2=1;i2<img_out.linhas;i2+=2){
        for(j2=1;j2<img_out.colunas;j2+=2){
            if((i2%2==0 && j2%2!=0)|| (i2%2!=0 && j2%2==0)){
                for(k=0;k<3;k++){
                    img_out.M[i2][j2][k]=img_out.M[i2-1][j2][k]+img_out.M[i2+1][j2][k]+img_out.M[i2][j2-1][k]+img_out.M[i2][j2+1][k];
                    img_out.M[i2][j2][k]=img_out.M[i2][j2][k]/4;
                }
            }
        }
    }
    salva_img("imagem_aumentada.ppm", img_out);
}

Img mascara (Img img_in){
    int i, j;
    Img mascara;

    mascara.linhas = img_in.linhas;
    mascara.colunas = img_in.colunas;

    for (i=0; i<mascara.linhas/2; i++){
        for (j=0; j<mascara.colunas; j++){
            mascara.M[i][j][0] = 255;
            mascara.M[i][j][1] = 255;
            mascara.M[i][j][2] = 255;
        }
    }

    for (i=mascara.linhas/2; i<mascara.linhas; i++){
        for (j=0; j<mascara.colunas; j++){
            mascara.M[i][j][0] = 0;
            mascara.M[i][j][1] = 0;
            mascara.M[i][j][2] = 0;
        }
    }

    return mascara;
}

void binariza(Img img_in, Img& img_out, int limiar){
    int i, j;

    img_out.linhas = img_in.linhas;
    img_out.colunas = img_in.colunas;

    for(i=0; i< img_in.linhas; i++){
        for(j=0; j < img_in.colunas; j++){
            int media = (img_in.M[i][j][0] + img_in.M[i][j][1] + img_in.M[i][j][2])/3;
            if (media < limiar) {
                img_out.M[i][j][0] = 0;
                img_out.M[i][j][1] = 0;
                img_out.M[i][j][2] = 0;
            }
            if (media >= limiar) {
                img_out.M[i][j][0] = 255;
                img_out.M[i][j][1] = 255;
                img_out.M[i][j][2] = 255;
            }
        }
    }

    salva_img("pretoebranco1.ppm", img_out);
}

void binariza_com_mascara(Img img_in, Img& img_out, int limiar){
    int i, j;

    img_out.linhas = img_in.linhas;
    img_out.colunas = img_in.colunas;

    for(i=0; i< img_in.linhas; i++){
        for(j=0; j < img_in.colunas; j++){
            if (mascara(img_in).M[i][j][0]==255 && mascara(img_in).M[i][j][1]==255 && mascara(img_in).M[i][j][2]==255){
                int media = (img_in.M[i][j][0] + img_in.M[i][j][1] + img_in.M[i][j][2])/3;
                if (media < limiar) {
                    img_out.M[i][j][0] = 0;
                    img_out.M[i][j][1] = 0;
                    img_out.M[i][j][2] = 0;
                }
                if (media >= limiar) {
                    img_out.M[i][j][0] = 255;
                    img_out.M[i][j][1] = 255;
                    img_out.M[i][j][2] = 255;
                }
            }
            else {
                img_out.M[i][j][0] = img_in.M[i][j][0];
                img_out.M[i][j][1] = img_in.M[i][j][1];
                img_out.M[i][j][2] = img_in.M[i][j][2];
            }
        }
    }

    salva_img("pretoebranco.ppm", img_out);
}

void cinza(Img img_in, Img& img_out){
    int i, j;

    img_out.linhas = img_in.linhas;
    img_out.colunas = img_in.colunas;

    for(i=0; i< img_in.linhas; i++){
        for(j=0; j < img_in.colunas; j++){
            int media = (img_in.M[i][j][0] + img_in.M[i][j][1] + img_in.M[i][j][2])/3;
                img_out.M[i][j][0] = media;
                img_out.M[i][j][1] = media;
                img_out.M[i][j][2] = media;
        }
    }
    salva_img("cinza.ppm", img_out);
}

void negativo (Img img_in, Img& img_out){
    for (int i=0; i<img_in.linhas; i++){
        for (int j=0; j<img_in.colunas; j++){
            img_out.M[i][j][0] = 255-img_in.M[i][j][0];
            img_out.M[i][j][1] = 255-img_in.M[i][j][1];
            img_out.M[i][j][2] = 255-img_in.M[i][j][2];
        }
    }
    salva_img("negativo.ppm", img_out);
}

void binariza_canal(Img img_in, Img& img_out, int limiar){
    int i, j;

    for(i=0; i<img_in.linhas; i++){
        for(j=0; j<img_in.colunas; j++){

            if (img_in.M[i][j][0]>=limiar){//vermelho
                img_out.M[i][j][0]=255;
            }
            else {
                img_out.M[i][j][0]=0;
            }

            if (img_in.M[i][j][1]>=limiar){//verde
                img_out.M[i][j][1]=255;
            }
            else {
                img_out.M[i][j][1]=0;
            }

            if (img_in.M[i][j][2]>=limiar){//azul
                img_out.M[i][j][2]=255;
            }
            else {
                img_out.M[i][j][2]=0;
            }

        }
    }
    salva_img("binarizar_canal.ppm", img_out);
}

void equaliza_histograma(Img img_in, Img& img_out){
    img_out.linhas=img_in.linhas;
    img_out.colunas=img_in.colunas;

    int h[3][256]={};
    int pixel,s;
    for(int i=0;i<img_in.linhas;i++){
        for(int j=0;j<img_in.colunas;j++){
            for(int k=0;k<3;k++){
                pixel=img_in.M[i][j][k];
                h[k][pixel]++;
            }
        }
    }
    for(int i=0;i<img_in.linhas;i++){
        for(int j=0;j<img_in.colunas;j++){
            for(int k=0;k<3;k++){
                s=0;
                for(int l=0;l<=img_in.M[i][j][k];l++){
                    s=s+h[k][l];
                }
                s=s*(255/(img_in.linhas*img_in.colunas));
                img_out.M[i][j][k]=s;
            }
        }
    }



}

void solariza (Img img_in, Img& img_out, int limiar){
    int i, j;

    for(i=0; i<img_in.linhas; i++){
        for(j=0; j<img_in.colunas; j++){

            if (img_in.M[i][j][0]<limiar){//vermelho
                img_out.M[i][j][0]=255-img_in.M[i][j][0];
            }

            if (img_in.M[i][j][1]<limiar){//vermelho
                img_out.M[i][j][1]=255-img_in.M[i][j][1];
            }

            if (img_in.M[i][j][2]<limiar){//vermelho
                img_out.M[i][j][2]=255-img_in.M[i][j][2];
            }

        }
    }

    img_out.linhas = img_in.linhas;
    img_out.colunas = img_in.colunas;

    salva_img("solariza.ppm", img_out);
}

void separa_canais (Img img_in, Img& img_r, Img& img_g, Img& img_b){

    for (int i=0; i<img_in.linhas; i++){
        for (int j=0; j<img_in.colunas; j++){

            img_r.M[i][j][0] = img_in.M[i][j][0];//vermelho
            img_r.M[i][j][1] = 0;
            img_r.M[i][j][2] = 0;


            img_g.M[i][j][1] = img_in.M[i][j][1];//verde
            img_r.M[i][j][0] = 0;
            img_r.M[i][j][2] = 0;

            img_b.M[i][j][2] = img_in.M[i][j][2];//azul
            img_r.M[i][j][0] = 0;
            img_r.M[i][j][1] = 0;

        }
    }

    img_r.colunas= img_in.colunas;
    img_r.linhas= img_in.linhas;

    img_g.colunas= img_in.colunas;
    img_g.linhas= img_in.linhas;

    img_b.colunas= img_in.colunas;
    img_b.linhas= img_in.linhas;

    salva_img("red.ppm", img_r);
    salva_img("green.ppm", img_g);
    salva_img("blue.ppm", img_b);

}


void inverte_verticalmente(Img img_in, Img& img_out){
    int i, j, k;

    img_out.linhas= img_in.linhas;
    img_out.colunas = img_in.colunas;

    for(i=0; i<img_in.linhas; i++){
        for(j=0; j<img_in.colunas; j++){
            for(k=0; k<3; k++){
                img_out.M[i][j][k] = img_in.M[img_in.linhas-i][j][k];
            }
        }
    }

    salva_img("Nova_imagem_invertida_verticalmente.ppm", img_out);
}

void inverte_horizontalmente(Img img_in, Img& img_out){
    int i, j, k;

    img_out.linhas= img_in.linhas;
    img_out.colunas = img_in.colunas;

    for(i=0; i<img_in.linhas; i++){
        for(j=0; j<img_in.colunas; j++){
            for(k=0; k<3; k++){
                img_out.M[i][j][k] = img_in.M[i][img_in.colunas-j][k];
            }
        }
    }

    salva_img("Nova_imagem_invertida_horizontalmente.ppm", img_out);
}

void reflete_horizontalmente(Img img_in, Img& img_out){
    int i, j, k, meio_fim=img_in.colunas/2, meio_inicio=img_in.colunas/2;

    img_out.linhas= img_in.linhas;
    img_out.colunas = img_in.colunas;

    for(j=0; j<=img_in.colunas/2; j++){
        for(i=0; i<img_in.linhas; i++){
            for(k=0; k<3; k++){
                img_out.M[i][meio_inicio][k] = img_in.M[i][img_in.colunas/2+j][k];
                img_out.M[i][meio_fim][k] = img_in.M[i][img_in.colunas/2+j][k];
            }
        }
        meio_inicio--;
        meio_fim++;
    }

    salva_img("Nova_imagem_refletida_horizontalmente1.ppm", img_out);
}

void reflete_verticalmente(Img img_in, Img& img_out){
    int i, j, k, meio_fim=img_in.linhas/2, meio_inicio=img_in.linhas/2;

    img_out.linhas= img_in.linhas;
    img_out.colunas = img_in.colunas;

    for(i=0; i<=img_in.linhas/2; i++){
        for(j=0; j<img_in.colunas; j++){
            for(k=0; k<3; k++){
                img_out.M[meio_inicio][j][k] = img_in.M[img_in.linhas/2+i][j][k];
                img_out.M[meio_fim][j][k] = img_in.M[img_in.linhas/2+i][j][k];
            }
        }
        meio_inicio--;
        meio_fim++;
    }


    salva_img("Nova_imagem_refletida_verti.ppm", img_out);
}

void filtragem_por_erosao(Img img_in, Img& img_out){
    int i,j,k;
    binariza(img_in,img_out, 127);
    img_out.linhas = img_in.linhas-1;
    img_out.colunas = img_in.colunas-1;

    for(i=0; i<img_out.linhas; i++)
    {
        for(j=0; j<img_out.colunas; j++)
        {
            for(k=0; k<3; k++)
            {
                if(img_in.M[i][j][k]==1 && img_in.M[i+1][j][k]==1 && img_in.M[i][j+1][k]==1 && img_in.M[i+1][j+1][k]==1)
                {
                    img_out.M[i][j][k]= 255;
                }
                else
                {
                    img_out.M[i][j][k]= 0;
                }

            }
        }
    }
    salva_img ("filtragem_por_erosao.ppm", img_out);
}

void filtragem_por_dilatacao(Img img_in, Img& img_out)
{
    int i,j,k;
    binariza(img_in,img_out,127);
    img_out.linhas = img_in.linhas-1;
    img_out.colunas = img_in.colunas-1;

    for(i=0; i<img_out.linhas; i++)
    {
        for(j=0; j<img_out.colunas; j++)
        {
            for(k=0; k<3; k++)
            {
                if(img_in.M[i][j][k]==1 || img_in.M[i+1][j][k]==1 || img_in.M[i][j+1][k]==1 || img_in.M[i+1][j+1][k]==1)
                {
                    img_out.M[i][j][k]= 255;
                }
                else
                {
                    img_out.M[i][j][k]= 0;
                }

            }
        }
    }
    salva_img("filtragem_por_dilatacao.ppm", img_out);
}



int main(){

    setlocale(LC_ALL, "Portuguese"); // permite a utilização de acentos provenientes da lingua portuguesa
    Img img;
    int x;

    //cout << endl<<"Informe o nome do arquivo que voce deseja abrir: " << endl;

    abre_img("lena.ppm", img);
    cout<<endl<<endl<<endl;

    do{

        //Menu da função

        cout<<endl<<"Selecione uma das opcoes:\n";
        cout<<" \t 1 - Converter para niveis de cinza \n";
        cout<<" \t 2 - Binarizar (preto e branco)\n ";
        cout<<" \t 3 - Binarizar (por canal) \n ";
        cout<<" \t 4 - Computar negativo \n ";
        cout<<" \t 5 - Solarizar \n ";
        cout<<" \t 6 - Separa canais \n";
        cout<<" \t 7 - Rotacionar imagem (horario) \n ";
        cout<<" \t 8 - Rotacionar imagem (anti-horario) \n ";
        cout<<" \t 9 - Inverter imagem (horizontalmente) \n ";
        cout<<" \t 10- Inverter imagem (verticalmente) \n ";
        cout<<" \t 11- Refletir imagem (horizontalmente) \n ";
        cout<<" \t 12- Refletir imagem (verticalmente) \n ";
        cout<<" \t 13- Reduzir tamanho \n ";
        cout<<" \t 14- Aumentar tamanho \n ";
        cout<<" \t 15- Filtrar com Passa Baixas (tamanho fixo) \n";
        cout<<" \t 16- Filtrar com erosao \n ";
        cout<<" \t 17- Filtrar com dilatacao \n ";
        cout<<" \t 18- Filtrar com Passa Altas \n ";
        cout<<" \t 19- Equalizar Histograma \n ";
        cout<<" \t 20- Filtrar com Mediana \n ";
        cout<<" \t 21- Filtrar com Passa Baixas (tamanho variavel) \n";
        cout<<" \t 22- Mascara \n ";
        cout <<"\t 23- Cortar imagem \n";
        cout<<"\t 24- Sair \n ";

        cout << "Qual opção você deseja escolher? ";
        cin >> x;

        switch(x){
            case 1:
                Img acinzentada;
                cinza(img, acinzentada);
            break;

            case 2:
                Img pretoebranco;
                binariza(img, pretoebranco,127);
            break;
            case 3:
                Img canal;
                binariza_canal(img, canal, 127);
            break;

            case 4:
                Img ngt;
                negativo(img, ngt);
            break;

            case 5:
                Img solarizada;
                solariza(img, solarizada, 55);
            break;

            case 6:
                Img red, green, blue;
                separa_canais(img, red, green, blue);
            break;

            case 7:
                Img horario;
                rotaciona(img, horario);
            break;

            case 8:
                Img antihorario;
                rotaciona_antihorario(img, antihorario);
            break;

            case 9:
                Img invertidahorizontalmente;
                inverte_horizontalmente(img, invertidahorizontalmente);
            break;

            case 10:
                Img invertidaverticalmente;
                inverte_verticalmente(img, invertidaverticalmente);
            break;

            case 11:
                Img refletida_horizontalmente;
                reflete_horizontalmente(img, refletida_horizontalmente);
            break;

            case 12:
                Img refletida_verticalmente;
                reflete_verticalmente(img, refletida_verticalmente);
            break;

            case 13:
                Img tamanhoreduzido;
                diminui_tamanho(img, tamanhoreduzido);
            break;

            case 14:
                Img tamanhoaumentado;
                aumenta_tamanho(img, tamanhoaumentado);
            break;

            case 15:

            break;

            case 16:
                Img filtrada_erosao;
                filtragem_por_erosao(img, filtrada_erosao);
            break;

            case 17:
                Img filtrada_dilatacao;
                filtragem_por_dilatacao(img, filtrada_dilatacao);
            break;

            case 18:

            break;

            case 19:
                Img equalizada_histograma;
                equaliza_histograma(img, equalizada_histograma);
            break;

            case 20:

            break;

            case 21:

            break;

            case 22:
                mascara(img);
            break;

            case 23:

            break;

            case 24:
                cout << "xau xau";
            break;

        }

    }while(x!=24);

    return 0;
}
